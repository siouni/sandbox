
## 📁 プロジェクト構造

* `/echo_studio`: Gradio アプリケーションのメインコード
  * `/[機能名].py`: 各機能ごとのUIコンポーネントとビジネスロジック
  * `/utils.py`: ユーティリティ関数
* `/sample`: サンプルコード（ここは書き換えない事）
  * `framepack.py`: FramePack（musubi-tuner）の実装サンプル
* `/tests`: ユニットテストおよび統合テスト
* `webui.py`: アプリケーションのエントリーポイント

## 🧑‍💻 コーディング規約
- **命名規則**:
  - クラス: PascalCase
  - 関数/変数: snake_case
  - 定数: UPPER_SNAKE_CASE
  - プライベート: 先頭に `_`

* Python のコードスタイルは [PEP 8](https://pep8.org/) に準拠し、`black` を使用して整形します。
* 関数や変数の命名には、意味のある名前を使用し、略語は避けます。
* 関数やクラスには適切な docstring を追加し、引数や戻り値の型を明示します。
* 各機能毎に[機能名].pyファイルを作成し、[機能名]Paramsクラスと[機能名]UIクラス、[機能名]クラスを最低限作成します。
* 機能で入出力する値は、[機能名]Paramstクラスとして、@dataclassで作成します。
* 必要に応じてサブ@dataclassの作成も許可します。
* Gradio コンポーネントの定義は[機能名]UIクラスで行い、コンストラクタでプロパティとして定義します。
* ビジネスロジックは、プライベートなグローバル関数として定義し、[機能名]クラスのインスタンスメソッドからサブプロセスとして起動します。
* 各機能毎のコンポーネントは、webui.pyファイル上でレイアウトします。
* イベントハンドラは、webui.pyで行い、[機能名]UIクラスのインスタンスメソッドを呼び出します。
* [機能名]UIクラスのインスタンスメソッドは、[機能名]クラスのインスタンスメソッドを呼び出します。その際にPoolとQueueを作成し、[機能名]クラスのインスタンスメソッドにはそれらを必ず渡すようにします。
* 機能名]クラスのインスタンスメソッドは、渡されたPoolとQueueを使用し、ビジネスロジックをサブプロセスで実行します。
* この辺の詳細はサンプルコード「/sample/framepack.py」を参考にしてください。
* サンプルコードはこのコーディング規約を作るための叩き台として作成したものなので、若干ルールに反しているものがあるかもしれません。その場合はルールを優先してください。

## 🧪 テスト

* テストフレームワークには `pytest` を使用します。
* テストコードは `/tests` ディレクトリに配置し、`test_*.py` の形式で命名します。
* テストの実行コマンド：
  ```bash
  pytest tests/
  ```
* コードカバレッジは 90%以上を目指します。()

## 🔧 プルリクエストのガイドライン

* プルリクエストのタイトルは、変更内容を簡潔に表現します。
* 説明には、変更の背景、目的、影響範囲を明記します。
* 関連する Issue がある場合は、`Closes #issue_number` の形式で記述します。
* UI に変更がある場合は、スクリーンショットを添付します。()

## ✅ チェックリスト

* [ ] コードが `black` で整形されている
* [ ] `pytest` で全てのテストが成功している
* [ ] 必要な docstring が追加されている
* [ ] UI の変更がある場合、スクリーンショットが添付されている()

